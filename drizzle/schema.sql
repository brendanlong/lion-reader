--
-- Lion Reader Database Schema
-- Generated by: pnpm db:schema
--
-- This file is auto-generated from the current database state.
-- It provides a snapshot of the schema for reference and review.
-- Do not edit manually - changes should be made via migrations.
--

CREATE EXTENSION IF NOT EXISTS citext WITH SCHEMA public;

CREATE TYPE public.feed_type AS ENUM (
    'web',
    'email',
    'saved'
);

CREATE TYPE public.websub_state AS ENUM (
    'pending',
    'active',
    'unsubscribed'
);

CREATE TABLE public.api_tokens (
    id uuid NOT NULL,
    user_id uuid NOT NULL,
    token_hash text NOT NULL,
    scopes text[] DEFAULT '{}'::text[] NOT NULL,
    name text,
    created_at timestamp with time zone DEFAULT now() NOT NULL,
    expires_at timestamp with time zone,
    revoked_at timestamp with time zone,
    last_used_at timestamp with time zone
);

CREATE TABLE public.blocked_senders (
    id uuid NOT NULL,
    user_id uuid NOT NULL,
    sender_email text NOT NULL,
    blocked_at timestamp with time zone DEFAULT now() NOT NULL,
    list_unsubscribe_mailto text,
    unsubscribe_sent_at timestamp with time zone
);

CREATE TABLE public.entries (
    id uuid NOT NULL,
    feed_id uuid NOT NULL,
    guid text NOT NULL,
    url text,
    title text,
    author text,
    content_original text,
    summary text,
    published_at timestamp with time zone,
    fetched_at timestamp with time zone NOT NULL,
    content_hash text NOT NULL,
    created_at timestamp with time zone DEFAULT now() NOT NULL,
    updated_at timestamp with time zone DEFAULT now() NOT NULL,
    content_cleaned text,
    type public.feed_type NOT NULL,
    site_name text,
    image_url text,
    spam_score real,
    is_spam boolean DEFAULT false NOT NULL,
    list_unsubscribe_mailto text,
    list_unsubscribe_https text,
    list_unsubscribe_post boolean,
    last_seen_at timestamp with time zone,
    CONSTRAINT entries_last_seen_only_fetched CHECK (((type = 'web'::public.feed_type) = (last_seen_at IS NOT NULL))),
    CONSTRAINT entries_saved_metadata_only_saved CHECK (((type = 'saved'::public.feed_type) OR ((site_name IS NULL) AND (image_url IS NULL)))),
    CONSTRAINT entries_spam_only_email CHECK (((type = 'email'::public.feed_type) OR ((spam_score IS NULL) AND (is_spam = false)))),
    CONSTRAINT entries_unsubscribe_only_email CHECK (((type = 'email'::public.feed_type) OR ((list_unsubscribe_mailto IS NULL) AND (list_unsubscribe_https IS NULL) AND (list_unsubscribe_post IS NULL))))
);

CREATE TABLE public.feeds (
    id uuid NOT NULL,
    type public.feed_type NOT NULL,
    url text,
    title text,
    description text,
    site_url text,
    etag text,
    last_modified_header text,
    last_fetched_at timestamp with time zone,
    next_fetch_at timestamp with time zone,
    consecutive_failures integer DEFAULT 0 NOT NULL,
    last_error text,
    created_at timestamp with time zone DEFAULT now() NOT NULL,
    updated_at timestamp with time zone DEFAULT now() NOT NULL,
    hub_url text,
    self_url text,
    websub_active boolean DEFAULT false NOT NULL,
    user_id uuid,
    email_sender_pattern text,
    body_hash text,
    last_entries_updated_at timestamp with time zone,
    redirect_url text,
    redirect_first_seen_at timestamp with time zone,
    CONSTRAINT feed_type_user_id CHECK (((type = ANY (ARRAY['email'::public.feed_type, 'saved'::public.feed_type])) = (user_id IS NOT NULL)))
);

CREATE TABLE public.ingest_addresses (
    id uuid NOT NULL,
    user_id uuid NOT NULL,
    token public.citext NOT NULL,
    label text,
    created_at timestamp with time zone DEFAULT now() NOT NULL,
    deleted_at timestamp with time zone
);

CREATE TABLE public.invites (
    id uuid NOT NULL,
    token text NOT NULL,
    expires_at timestamp with time zone NOT NULL,
    used_at timestamp with time zone,
    used_by_user_id uuid,
    created_at timestamp with time zone DEFAULT now() NOT NULL
);

CREATE TABLE public.jobs (
    id uuid NOT NULL,
    type text NOT NULL,
    payload jsonb DEFAULT '{}'::jsonb NOT NULL,
    last_error text,
    created_at timestamp with time zone DEFAULT now() NOT NULL,
    enabled boolean DEFAULT true NOT NULL,
    next_run_at timestamp with time zone,
    running_since timestamp with time zone,
    last_run_at timestamp with time zone,
    consecutive_failures integer DEFAULT 0 NOT NULL,
    updated_at timestamp with time zone DEFAULT now() NOT NULL
);

CREATE TABLE public.narration_content (
    id uuid NOT NULL,
    content_hash text NOT NULL,
    content_narration text,
    generated_at timestamp with time zone,
    error text,
    error_at timestamp with time zone,
    created_at timestamp with time zone DEFAULT now() NOT NULL
);

CREATE TABLE public.oauth_accounts (
    id uuid NOT NULL,
    user_id uuid NOT NULL,
    provider text NOT NULL,
    provider_account_id text NOT NULL,
    access_token text,
    refresh_token text,
    expires_at timestamp with time zone,
    created_at timestamp with time zone DEFAULT now() NOT NULL,
    scopes text[]
);

CREATE TABLE public.opml_imports (
    id uuid NOT NULL,
    user_id uuid NOT NULL,
    status text DEFAULT 'pending'::text NOT NULL,
    total_feeds integer NOT NULL,
    imported_count integer DEFAULT 0 NOT NULL,
    skipped_count integer DEFAULT 0 NOT NULL,
    failed_count integer DEFAULT 0 NOT NULL,
    feeds_data jsonb NOT NULL,
    results jsonb DEFAULT '[]'::jsonb NOT NULL,
    error text,
    created_at timestamp with time zone DEFAULT now() NOT NULL,
    updated_at timestamp with time zone DEFAULT now() NOT NULL,
    completed_at timestamp with time zone
);

CREATE TABLE public.sessions (
    id uuid NOT NULL,
    user_id uuid NOT NULL,
    token_hash text NOT NULL,
    user_agent text,
    ip_address text,
    created_at timestamp with time zone DEFAULT now() NOT NULL,
    expires_at timestamp with time zone NOT NULL,
    revoked_at timestamp with time zone,
    last_active_at timestamp with time zone DEFAULT now() NOT NULL
);

CREATE TABLE public.subscription_tags (
    subscription_id uuid NOT NULL,
    tag_id uuid NOT NULL,
    created_at timestamp with time zone DEFAULT now() NOT NULL
);

CREATE TABLE public.subscriptions (
    id uuid NOT NULL,
    user_id uuid NOT NULL,
    feed_id uuid NOT NULL,
    custom_title text,
    subscribed_at timestamp with time zone DEFAULT now() NOT NULL,
    unsubscribed_at timestamp with time zone,
    created_at timestamp with time zone DEFAULT now() NOT NULL,
    updated_at timestamp with time zone DEFAULT now() NOT NULL,
    previous_feed_ids uuid[] DEFAULT '{}'::uuid[] NOT NULL,
    feed_ids uuid[] GENERATED ALWAYS AS ((ARRAY[feed_id] || previous_feed_ids)) STORED
);

CREATE TABLE public.tags (
    id uuid NOT NULL,
    user_id uuid NOT NULL,
    name text NOT NULL,
    color text,
    created_at timestamp with time zone DEFAULT now() NOT NULL
);

CREATE TABLE public.user_entries (
    user_id uuid NOT NULL,
    entry_id uuid NOT NULL,
    read boolean DEFAULT false NOT NULL,
    starred boolean DEFAULT false NOT NULL,
    updated_at timestamp with time zone DEFAULT now() NOT NULL
);

CREATE TABLE public.users (
    id uuid NOT NULL,
    email public.citext NOT NULL,
    email_verified_at timestamp with time zone,
    password_hash text,
    created_at timestamp with time zone DEFAULT now() NOT NULL,
    updated_at timestamp with time zone DEFAULT now() NOT NULL,
    invite_id uuid,
    show_spam boolean DEFAULT false NOT NULL
);

CREATE TABLE public.websub_subscriptions (
    id uuid NOT NULL,
    feed_id uuid NOT NULL,
    hub_url text NOT NULL,
    topic_url text NOT NULL,
    callback_secret text NOT NULL,
    state public.websub_state DEFAULT 'pending'::public.websub_state NOT NULL,
    lease_seconds integer,
    expires_at timestamp with time zone,
    last_challenge_at timestamp with time zone,
    last_error text,
    created_at timestamp with time zone DEFAULT now() NOT NULL,
    updated_at timestamp with time zone DEFAULT now() NOT NULL
);

ALTER TABLE ONLY public.api_tokens
    ADD CONSTRAINT api_tokens_pkey PRIMARY KEY (id);

ALTER TABLE ONLY public.api_tokens
    ADD CONSTRAINT api_tokens_token_hash_key UNIQUE (token_hash);

ALTER TABLE ONLY public.blocked_senders
    ADD CONSTRAINT blocked_senders_pkey PRIMARY KEY (id);

ALTER TABLE ONLY public.entries
    ADD CONSTRAINT entries_pkey PRIMARY KEY (id);

ALTER TABLE ONLY public.feeds
    ADD CONSTRAINT feeds_pkey PRIMARY KEY (id);

ALTER TABLE ONLY public.feeds
    ADD CONSTRAINT feeds_url_unique UNIQUE (url);

ALTER TABLE ONLY public.ingest_addresses
    ADD CONSTRAINT ingest_addresses_pkey PRIMARY KEY (id);

ALTER TABLE ONLY public.ingest_addresses
    ADD CONSTRAINT ingest_addresses_token_unique UNIQUE (token);

ALTER TABLE ONLY public.invites
    ADD CONSTRAINT invites_pkey PRIMARY KEY (id);

ALTER TABLE ONLY public.invites
    ADD CONSTRAINT invites_token_unique UNIQUE (token);

ALTER TABLE ONLY public.jobs
    ADD CONSTRAINT jobs_pkey PRIMARY KEY (id);

ALTER TABLE ONLY public.narration_content
    ADD CONSTRAINT narration_content_content_hash_unique UNIQUE (content_hash);

ALTER TABLE ONLY public.narration_content
    ADD CONSTRAINT narration_content_pkey PRIMARY KEY (id);

ALTER TABLE ONLY public.oauth_accounts
    ADD CONSTRAINT oauth_accounts_pkey PRIMARY KEY (id);

ALTER TABLE ONLY public.opml_imports
    ADD CONSTRAINT opml_imports_pkey PRIMARY KEY (id);

ALTER TABLE ONLY public.sessions
    ADD CONSTRAINT sessions_pkey PRIMARY KEY (id);

ALTER TABLE ONLY public.sessions
    ADD CONSTRAINT sessions_token_hash_unique UNIQUE (token_hash);

ALTER TABLE ONLY public.subscription_tags
    ADD CONSTRAINT subscription_tags_subscription_id_tag_id_pk PRIMARY KEY (subscription_id, tag_id);

ALTER TABLE ONLY public.subscriptions
    ADD CONSTRAINT subscriptions_pkey PRIMARY KEY (id);

ALTER TABLE ONLY public.tags
    ADD CONSTRAINT tags_pkey PRIMARY KEY (id);

ALTER TABLE ONLY public.blocked_senders
    ADD CONSTRAINT uq_blocked_senders_user_email UNIQUE (user_id, sender_email);

ALTER TABLE ONLY public.entries
    ADD CONSTRAINT uq_entries_feed_guid UNIQUE (feed_id, guid);

ALTER TABLE ONLY public.feeds
    ADD CONSTRAINT uq_feeds_email_user_sender UNIQUE (user_id, email_sender_pattern);

ALTER TABLE ONLY public.oauth_accounts
    ADD CONSTRAINT uq_oauth_accounts_provider_account UNIQUE (provider, provider_account_id);

ALTER TABLE ONLY public.subscriptions
    ADD CONSTRAINT uq_subscriptions_user_feed UNIQUE (user_id, feed_id);

ALTER TABLE ONLY public.tags
    ADD CONSTRAINT uq_tags_user_name UNIQUE (user_id, name);

ALTER TABLE ONLY public.websub_subscriptions
    ADD CONSTRAINT uq_websub_subscriptions_feed_hub UNIQUE (feed_id, hub_url);

ALTER TABLE ONLY public.user_entries
    ADD CONSTRAINT user_entry_states_user_id_entry_id_pk PRIMARY KEY (user_id, entry_id);

ALTER TABLE ONLY public.users
    ADD CONSTRAINT users_email_unique UNIQUE (email);

ALTER TABLE ONLY public.users
    ADD CONSTRAINT users_pkey PRIMARY KEY (id);

ALTER TABLE ONLY public.websub_subscriptions
    ADD CONSTRAINT websub_subscriptions_pkey PRIMARY KEY (id);

CREATE INDEX idx_api_tokens_token ON public.api_tokens USING btree (token_hash);

CREATE INDEX idx_api_tokens_user ON public.api_tokens USING btree (user_id);

CREATE INDEX idx_blocked_senders_user ON public.blocked_senders USING btree (user_id);

CREATE INDEX idx_entries_feed ON public.entries USING btree (feed_id, id);

CREATE INDEX idx_entries_feed_type ON public.entries USING btree (feed_id, type);

CREATE INDEX idx_entries_fetched ON public.entries USING btree (feed_id, fetched_at);

CREATE INDEX idx_entries_last_seen ON public.entries USING btree (feed_id, last_seen_at) WHERE (type = 'web'::public.feed_type);

CREATE INDEX idx_entries_spam ON public.entries USING btree (feed_id, is_spam);

CREATE INDEX idx_entries_type ON public.entries USING btree (type);

CREATE INDEX idx_feeds_next_fetch ON public.feeds USING btree (next_fetch_at);

CREATE INDEX idx_feeds_type ON public.feeds USING btree (type);

CREATE INDEX idx_feeds_user_id ON public.feeds USING btree (user_id);

CREATE INDEX idx_ingest_addresses_token ON public.ingest_addresses USING btree (token);

CREATE INDEX idx_ingest_addresses_user ON public.ingest_addresses USING btree (user_id);

CREATE INDEX idx_invites_expires ON public.invites USING btree (expires_at);

CREATE INDEX idx_invites_token ON public.invites USING btree (token);

CREATE INDEX idx_jobs_feed_id ON public.jobs USING btree (((payload ->> 'feedId'::text))) WHERE (type = 'fetch_feed'::text);

CREATE INDEX idx_jobs_polling ON public.jobs USING btree (next_run_at) WHERE (enabled = true);

CREATE INDEX idx_narration_needs_generation ON public.narration_content USING btree (id);

CREATE INDEX idx_oauth_accounts_scopes ON public.oauth_accounts USING gin (scopes);

CREATE INDEX idx_oauth_accounts_user ON public.oauth_accounts USING btree (user_id);

CREATE INDEX idx_opml_imports_status ON public.opml_imports USING btree (status);

CREATE INDEX idx_opml_imports_user ON public.opml_imports USING btree (user_id);

CREATE INDEX idx_sessions_token ON public.sessions USING btree (token_hash);

CREATE INDEX idx_sessions_user ON public.sessions USING btree (user_id);

CREATE INDEX idx_subscription_tags_subscription ON public.subscription_tags USING btree (subscription_id);

CREATE INDEX idx_subscription_tags_tag ON public.subscription_tags USING btree (tag_id);

CREATE INDEX idx_subscriptions_feed ON public.subscriptions USING btree (feed_id);

CREATE INDEX idx_subscriptions_feed_active ON public.subscriptions USING btree (feed_id) WHERE (unsubscribed_at IS NULL);

CREATE INDEX idx_subscriptions_feed_ids ON public.subscriptions USING gin (feed_ids);

CREATE INDEX idx_subscriptions_user ON public.subscriptions USING btree (user_id);

CREATE INDEX idx_subscriptions_user_active ON public.subscriptions USING btree (user_id) WHERE (unsubscribed_at IS NULL);

CREATE INDEX idx_tags_user ON public.tags USING btree (user_id);

CREATE INDEX idx_user_entries_entry_id ON public.user_entries USING btree (entry_id);

CREATE INDEX idx_user_entries_starred ON public.user_entries USING btree (user_id) WHERE (starred = true);

CREATE INDEX idx_user_entries_unread ON public.user_entries USING btree (user_id) WHERE (read = false);

CREATE INDEX idx_user_entries_updated_at ON public.user_entries USING btree (user_id, updated_at);

CREATE INDEX idx_websub_expiring ON public.websub_subscriptions USING btree (expires_at);

CREATE INDEX idx_websub_feed ON public.websub_subscriptions USING btree (feed_id);

CREATE UNIQUE INDEX uq_feeds_saved_user ON public.feeds USING btree (user_id) WHERE (type = 'saved'::public.feed_type);

ALTER TABLE ONLY public.api_tokens
    ADD CONSTRAINT api_tokens_user_id_fkey FOREIGN KEY (user_id) REFERENCES public.users(id) ON DELETE CASCADE;

ALTER TABLE ONLY public.blocked_senders
    ADD CONSTRAINT blocked_senders_user_id_users_id_fk FOREIGN KEY (user_id) REFERENCES public.users(id) ON DELETE CASCADE;

ALTER TABLE ONLY public.entries
    ADD CONSTRAINT entries_feed_id_feeds_id_fk FOREIGN KEY (feed_id) REFERENCES public.feeds(id) ON DELETE CASCADE;

ALTER TABLE ONLY public.feeds
    ADD CONSTRAINT feeds_user_id_users_id_fk FOREIGN KEY (user_id) REFERENCES public.users(id) ON DELETE CASCADE;

ALTER TABLE ONLY public.ingest_addresses
    ADD CONSTRAINT ingest_addresses_user_id_users_id_fk FOREIGN KEY (user_id) REFERENCES public.users(id) ON DELETE CASCADE;

ALTER TABLE ONLY public.oauth_accounts
    ADD CONSTRAINT oauth_accounts_user_id_users_id_fk FOREIGN KEY (user_id) REFERENCES public.users(id) ON DELETE CASCADE;

ALTER TABLE ONLY public.opml_imports
    ADD CONSTRAINT opml_imports_user_id_fkey FOREIGN KEY (user_id) REFERENCES public.users(id) ON DELETE CASCADE;

ALTER TABLE ONLY public.sessions
    ADD CONSTRAINT sessions_user_id_users_id_fk FOREIGN KEY (user_id) REFERENCES public.users(id) ON DELETE CASCADE;

ALTER TABLE ONLY public.subscription_tags
    ADD CONSTRAINT subscription_tags_subscription_id_subscriptions_id_fk FOREIGN KEY (subscription_id) REFERENCES public.subscriptions(id) ON DELETE CASCADE;

ALTER TABLE ONLY public.subscription_tags
    ADD CONSTRAINT subscription_tags_tag_id_tags_id_fk FOREIGN KEY (tag_id) REFERENCES public.tags(id) ON DELETE CASCADE;

ALTER TABLE ONLY public.subscriptions
    ADD CONSTRAINT subscriptions_feed_id_feeds_id_fk FOREIGN KEY (feed_id) REFERENCES public.feeds(id) ON DELETE CASCADE;

ALTER TABLE ONLY public.subscriptions
    ADD CONSTRAINT subscriptions_user_id_users_id_fk FOREIGN KEY (user_id) REFERENCES public.users(id) ON DELETE CASCADE;

ALTER TABLE ONLY public.tags
    ADD CONSTRAINT tags_user_id_users_id_fk FOREIGN KEY (user_id) REFERENCES public.users(id) ON DELETE CASCADE;

ALTER TABLE ONLY public.user_entries
    ADD CONSTRAINT user_entry_states_entry_id_entries_id_fk FOREIGN KEY (entry_id) REFERENCES public.entries(id) ON DELETE CASCADE;

ALTER TABLE ONLY public.user_entries
    ADD CONSTRAINT user_entry_states_user_id_users_id_fk FOREIGN KEY (user_id) REFERENCES public.users(id) ON DELETE CASCADE;

ALTER TABLE ONLY public.users
    ADD CONSTRAINT users_invite_id_invites_id_fk FOREIGN KEY (invite_id) REFERENCES public.invites(id) ON DELETE SET NULL;

ALTER TABLE ONLY public.websub_subscriptions
    ADD CONSTRAINT websub_subscriptions_feed_id_feeds_id_fk FOREIGN KEY (feed_id) REFERENCES public.feeds(id) ON DELETE CASCADE;
